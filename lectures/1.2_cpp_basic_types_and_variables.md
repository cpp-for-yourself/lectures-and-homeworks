---
marp: true
theme: custom-theme
footer: ![width:80px](images/C++ForYourselfIcon.png)
---

# Basics of C++
#### Variables and some useful types
- Fundamental types
- Variables
- Basic types
- Naming variables
- `const`, `constexpr` and references
---
# Prerequisites:
- [Hello world dissection lecture](1.1_hello_world_dissection.md)

---
# Special symbols used in slides
- 🎨 - Style recommendation
- 🎓 - Software design recommendation
- 😱 - **Not** a good code snippet or line of code! Avoid in real life!
- ❌ - Don't do whatever follows (or precedes) this
- ✅ - Do this instead
- 🚨 - Alert! Important information!

Style (🎨) and software design (🎓) recommendations mostly come from [Google Style Sheet](https://google.github.io/styleguide/cppguide.html) and the [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)

---

# Declaring variables
Variable declaration follows one of the following patterns:
```cpp
Type variable_name;  // 😱 Uninitialized! Contains random value!
Type variable_name = value;
Type variable_name{value};  // Follows "uniform initialization"
Type variable_name{};  // "Value initialization" if possible
Type variable_name(value);  // ❌ Mostly not used nowadays
```
- Every variable **has a type** - one of the defining features of C++
- Variables cannot change their type
- Variables cannot be assigned an incompatible type

---

# Naming variables

- Name **must** start with a letter
- C++ is case sensitive:
  `some_var` $\ne$ `some_Var` $\ne$ `someVar`
- 🎨 Give variables **meaningful names**
- 🎨 Don't be afraid to **use longer names**
- 🎨 Name variables in `snake_case`
  (all lowercase, underscores separate words)
- 🎨:x: **Don't include type** in the name
- 🎨:x: **Don't use negation** in the name

See [Google naming rules](https://google.github.io/styleguide/cppguide.html#General_Naming_Rules) for more details

---

# [Fundamental types](https://en.cppreference.com/w/cpp/language/types) in C++
- `void` type to represent "nothing" (stay tuned)
- **Integer** types (`signed` and `unsigned`)
  - `short`
  - `int`
  - `long`
  - `long long`
- **Boolean** type: `bool` to represent `true` or `false`
- **Character** type: `char` and unsigned `unsigned char`
  - Very similar to `int` but smaller range: `[-128, 127]`
- **Floating point** types:
  - `float` - **single** precision floating point number
  - `double` - **double** precision floating point number

---

# Variables of fundamental types
```cpp
bool this_is_fun = false;      // Boolean: true or false
char caret_return = '\n';      // Single character
int meaning_of_life = 42;      // Integer number
short smaller_int{42};         // Short number (using {})
long bigger_int = 42L;         // Long number (L is a literal)
float fraction = 0.01f;        // Single precision float
double precise_num = 0.01;     // Double precision float
double scientific = 2.42e-10;  // Double precision float
auto some_int{42};             // Automatic type [int] (using {})
auto some_float = 13.0F;       // Automatic type [float]
auto some_double = 13.0;       // Automatic type [double]
```
There are also `unsigned` equivalents for integer types
```cpp
unsigned int meaning_of_life = 42U;   // Unsigned integer number
unsigned long bigger_int = 42UL;      // Unsigned long number
auto number = 42'232'424ul;  // Automatic type [unsigned long]
auto number_copy = number;   // Automatic type [unsigned long]
unsigned long explicit_copy = number; // This works too!
```

---

# Always initialize all variables! 🚨

There are rare cases where this is not possible like [performance](draft_performance.md) considerations, we will cover them later in the course
```cpp
int sad_uninitialized_variable;  // 😱 Really, don't do this!
```
```cpp
bool initializing_is_good = true;  // ✅ Always initialize!
bool use_uniform_initialization{true};
auto also_works_with_auto{true};
auto this_works_too = true;
```
# Also use "value initialization"
```cpp
bool set_to_default_value{};  // Initialize to false
int some_int_number{};        // Initialize to 0
double some_double_number{};  // Initialize to 0.0
float some_float_number{};    // Initialize to 0.0F
auto does_not_work{};         // ❌ no info on the type!
```
---

# Uninitialized variable example 😱

Let's consider an example:
```cpp
#include <cstdio>
int main() {
    double uninitialized_variable;  // 😱 Don't do this!
    std::printf("%e\n", uninitialized_variable);
}
```
Here is the typical output:
```
λ › ./test
2.14188e-314
λ › ./test
2.12718e-314
λ › ./test
2.12991e-314
```
- The value of `uninitialized_variable` is "undefined"
- Your results will (probably) be different!
- Relying on this value causes **"Undefined Behavior"** (**UB**)

---

# Initialization vs assignment
We can also **initialize** the variables from other variables
```cpp
int some_int{other_int};
auto some_int_copy = some_int;
```
Also, we can **assign** a value to an **existing** variable
```
some_int_copy = 42;
some_int = some_int_copy;
```
### How to tell one from another? :thinking:
Both initialization and assignment use `=` to set value
Here is a rule of thumb to tell them apart :+1:
- If a statement **creates a new variable** - it is an **initialization**
- If not - it is an **assignment**

---

# const and constexpr
`const` - constant, `constexpr` - constant expression
<div class="grid-container">
<div>

### `const`
- Can be used for constants created at **run time**
- Can be initialized with **any** provided value
- _Sometimes_ will be available at compile time
```cpp
int a = 42;
const int b = a;   // ✅
const int c = 23;  // ✅
const int d = c;   // ✅
```

</div>

<div>

### `constexpr`
- Can only be used for constants created at 
  **compile time**
- Can only be initialized from a `constexpr` value
```cpp
int a = 42;
const int a_const = a;
constexpr int b = a;       // ❌
constexpr int c = a_const; // ❌
constexpr int d = 23;      // ✅
constexpr int e = d;       // ✅
```

</div>
</div>

---

# When to use const and constexpr?
Here is the rule of thumb to declare **anything**:
1. Can you declare it as `constexpr`? If yes - do it ✅
2. Can you declare it `const`? If yes - do it ✅
3. Otherwise, declare it as a normal variable

---

# References to variables
- We can create a **reference** to any variable
- Use `&` to state that a variable is a reference
  - `auto & ref = original_variable;`
- Reference is part of the type:
  variable `ref` has type `float &`
- Changing a reference changes the variable and vice versa
    ```c++
    int some_variable = 42;
    int& some_variable_ref = some_variable;
    some_variable_ref = 23;
    // some_variable is now == 23
    ```
- Yields performance gain as references **avoid copying data**
  Will be more important when we talk about functions later

---

# Const with references

- References are fast but reduce control
- To avoid unwanted changes use `const`
  - `const auto & ref = original_variable;`

```cpp
#include <cstdio>

int main() {
  int num = 42;  // Name has to fit on the slides ¯\_(ツ)_/¯
  int& ref = num;
  const int& const_ref = num;
  std::printf("ref: %d, const_ref: %d\n", ref, const_ref);
  ref = 0;
  std::printf("ref: %d, const_ref: %d\n", ref, const_ref);
  num = 23;
  std::printf("ref: %d, const_ref: %d\n", ref, const_ref);
  return 0;
}
```

---

# All variables live in scopes
- There is a single **global scope** (outside of all functions)
- Local scopes start with `{` and end with `}`
- All variables **live in the scope** where they have been declared
- All variables die in the **end of their scope**
- Variables can "shadow" other variables from outer scopes
- ‼️ This is the core principle of C++ memory management!
```cpp
// 😱 Don't put variables here, just an illustration
int global_variable{42};  

int main() {  // Start of main scope
  float some_float = 13.13F;  // Create variable
  {  // New inner scope
    auto some_float = 42.42F;  // "Shadows" some_float
    auto another_float = some_float;  // Copy variable
  }  // another_float and the shadow of some_float die
  return 0;
}  // Variable some_float dies
// Variable global_variable dies at the end of the program
```

---

# Naming of constants
- 🎨 Name constants in the **global scope** in `CamelCase` starting with a small letter `k`:
```cpp
constexpr float kImportantFloat = 42.42f;
const int kHello{42};
```
- 🎨 Name constants in any **local scope** in `snake_case`
```cpp
const auto local_scope_constant{42UL};
```
- Keyword `const` is part of the variable's type:
  variable `kHello` above has type `const int`

Check out the [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html#Constant_Names) for more details


---

# Operations on [arithmetic types](https://en.cppreference.com/w/c/language/arithmetic_types)
- All **character**, **integer** and **floating point** types are **arithmetic**
- Arithmetic operations: `+`, `-`, `*`, `/`, `%` (modulo division)
- Comparisons `<`, `>`, `<=`, `>=`, `==` return `bool`
- `a += 1` $\Leftrightarrow$ `a = a + 1`, same for `-=`, `*=`, `/=`, etc.
- Avoid `==` for floating point types
  (we'll cover a better way later)
### Be careful with unsigned integers!
```cpp
#include <cstdio>
int main() {
    std::printf("%u\n", 23U - 42U);
    return 0;
}
```
Prints `4294967277` due to an "underflow" (stay tuned)

---

# Some additional operations
- Logical operations defined over boolean variables:
  **or**: `||`, **and**: `&&`, **not**: `!`
    ```cpp
    bool is_happy = (!is_hungry && is_warm) || is_rich;
    ```
- Additional operations on integer variables:
- `/` is integer division: i.e. `7 / 3 == 2`
- `%` is modulo division: i.e. `7 % 3 == 1`
- **Increment** operator: `a++` $\Leftrightarrow$ `++a` $\Leftrightarrow$ `a += 1`
- **Decrement** operator: `a--` $\Leftrightarrow$ `--a` $\Leftrightarrow$ `a -= 1`
- ❌ **Do not** use de- increment operators within another expression, i.e., 😱 `a = (a++) + ++b` 😱

