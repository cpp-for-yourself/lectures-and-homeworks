---
marp: true
theme: custom-theme
footer: ![width:80px](images/C++ForYourselfIcon.png)
---

# Basics of C++
## Variables and some useful types
- Variables
- Basic types
- More interesting types
  - `std::string`
  - `std::array`
  - `std::vector`
  - Streams
- `const`, `constexpr` and references

---
# Special symbols used in slides
- üé® - Style recommendation
- üéì - Software design recommendation
- üò± - **Not** a good code snippet or line of code! Avoid in real life!
- ‚ùå - Don't do whatever follows (or precedes) this
- ‚úÖ - Do this instead
- üö® - Alert! Important information!

Style (üé®) and software design (üéì) recommendations mostly come from [Google Style Sheet](https://google.github.io/styleguide/cppguide.html) and the [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)

---

# Declaring variables
Variable declaration follows one of the following patterns:
```cpp
Type variable_name;  // üò± Uninitialized! Contains random value!
Type variable_name = value;
Type variable_name{value};  // Follows "uniform initialization"
Type variable_name{};  // "Value initialization" if possible
Type variable_name(value);  // ‚ùå Mostly not used nowadays
```
- Every variable **has a type** - one of the defining features of C++
- Variables cannot change their type
- Variables cannot be assigned an incompatible type
- **Always initialize** variables if you can
```cpp
int sad_uninitialized_variable;  // üò± Really, don't do this!
```
```cpp
bool initializing_is_good = true;  // ‚úÖ Always initialize!
bool use_uniform_initialization{true};
auto also_works_with_auto{true};
bool set_to_default_value{};  // Will initialize to false
```

---
# Uninitialized variable example

Let's consider an example:
```cpp
#include <iostream>
int main() {
    double uninitialized_variable;  // üò± Don't do this!
    std::cout << uninitialized_variable << std::endl;
}
```
Here is the typical output:
```
Œª ‚Ä∫ ./test
2.14188e-314
Œª ‚Ä∫ ./test
2.12718e-314
Œª ‚Ä∫ ./test
2.12991e-314
```
- The value of `uninitialized_variable` is "undefined"
- Your results will (probably) be different!
- Relying on this value causes **"Undefined Behavior"** (**UB**)

---

# Naming variables

- Name **must** start with a letter
- C++ is case sensitive:
  `some_var` $\ne$ `some_Var` $\ne$ `someVar`
- üé® Give variables **meaningful names**
- üé® Don't be afraid to **use longer names**
- üé® Name variables in `snake_case`
  (all lowercase, underscores separate words)
- üé®:x: **Don't include type** in the name
- üé®:x: **Don't use negation** in the name


<!-- _footer: Google naming rules: https://google.github.io/styleguide/cppguide.html#General_Naming_Rules ![width:80px](images/C++ForYourselfIcon.png) -->

---

# "Out of the box" types in C++
```cpp
bool this_is_fun = false;      // Boolean: true or false
char caret_return = '\n';      // Single character
int meaning_of_life = 42;      // Integer number
short smaller_int = 42;        // Short number
long bigger_int = 42L;         // Long number (L is a literal)
float fraction = 0.01f;        // Single precision float
double precise_num = 0.01;     // Double precision float
double scientific = 2.42e-10;  // Double precision float
auto some_int = 13;            // Automatic type [int]
auto some_float = 13.0F;       // Automatic type [float]
auto some_double = 13.0;       // Automatic type [double]
```
There are also `unsigned` equivalents for integer types
```cpp
unsigned int meaning_of_life = 42U;   // Unsigned integer number
unsigned long bigger_int = 42UL;      // Unsigned long number
auto number = 42'232'424ul;  // Automatic type [unsigned long]
```

`[Advanced]` If curious read detailed info here:
https://en.cppreference.com/w/cpp/language/types

---

# Operations on arithmetic types
- All **character**, **integer** and **floating point** types are **arithmetic**
- Arithmetic operations: `+`, `-`, `*`, `/`, `%` (modulo division)
- Comparisons `<`, `>`, `<=`, `>=`, `==` return `bool`
- `a += 1` $\Leftrightarrow$ `a = a + 1`, same for `-=`, `*=`, `/=`, etc.
- Avoid `==` for floating point types
  (we'll cover a better way later)
### Be careful with unsigned integers!
```cpp
#include <iostream>
int main() {
    std::cout << 23U - 42U << std::endl;
    return 0;
}
```
Prints `4294967277` due to an "underflow" (stay tuned)


<!-- _footer: Read more on arithmetic types: https://en.cppreference.com/w/c/language/arithmetic_types ![width:80px](images/C++ForYourselfIcon.png) -->


---

# Some additional operations
- Logical operations defined over boolean variables:
  **or**: `||`, **and**: `&&`, **not**: `!`
    ```cpp
    bool is_happy = (!is_hungry && is_warm) || is_rich;
    ```
- Additional operations on integer variables:
- `/` is integer division: i.e. `7 / 3 == 2`
- `%` is modulo division: i.e. `7 % 3 == 1`
- **Increment** operator: `a++` $\Leftrightarrow$ `++a` $\Leftrightarrow$ `a += 1`
- **Decrement** operator: `a--` $\Leftrightarrow$ `--a` $\Leftrightarrow$ `a -= 1`
- ‚ùå **Do not** use de- increment operators within another expression, i.e., üò± `a = (a++) + ++b` üò±

---
# I/O streams for input and output
- Function `puts` was only good to print constant characters
- Handle `stdin`, `stdout` and `stderr` with streams: 
  - `std::cin` ‚Äî maps to `stdin`
  - `std::cout` ‚Äî maps to `stdout` 
  - `std::cerr` ‚Äî maps to `stderr`
- `#include <iostream>` to use I/O streams 
- Part of the C++ standard library (**STL**)

```cpp
#include <iostream> 
int main() {
    int some_number{};
    std::cin >> some_number;
    std::cout << "number = " << some_number << std::endl; 
    std::cerr << "boring error message" << std::endl; 
    return 0;
}
```

---

# Strings
- `#include <string>` to use `std::string`
- Concatenate strings with `+`
- Check if `str` is empty with `str.empty()`
- Works out of the box with I/O streams

```cpp
#include <iostream>
#include <string>

int main() {
  std::string hello = "Hello";
  std::cout << "Type your name:" << std::endl;
  std::string name = "";  // Init empty.
  std::cin >> name;       // Read name.
  std::cout << hello + ", " + name + "!" << std::endl;
  return 0;
}
```

---

# Use `std::array` for fixed size collections of items
- `#include <array>` to use `std::array`
- Store a **collection of items** of **same type**
- Create from data:
    ```cpp
    std::array<float, 3> arr = {1.0F, 2.0F, 3.0F};
    ```
- Access items with `arr[i]` or `arr.at(i)`
- indexing starts with `0`
- Number of stored items: `arr.size()`
- Useful access aliases:
  - First item: `arr.front() == arr[0UL]`
  - Last item:`arr.back() == arr[arr.size() - 1UL]`

---

# Use `std::vector` if number of items is unknown at compile time
- `#include <vector>` to use `std::vector`
- Vector is implemented as a **dynamic table**
- Access stored items just like in `std::array`
- Remove all elements: `vec.clear()`
- Add a new item in one of two ways:
  - `vec.emplace_back(value)` **[preferred, c++11]**
  - `vec.push_back(value)` **[historically better known]**
#### Use it! It is fast and flexible!
Consider it to be a default container to store collections of items of any _one_ type

---

# Optimize vector resizing
- Many `push_back`/`emplace_back` operations force `std::vector` to change its size many times
- `reserve(n)` ensures that the vector has enough memory to store `n` items
- The parameter `n` can even be approximate
- This is a **very important optimization**
  
```cpp
// Somewhere within the main function
std::vector<float> vec;
const int number_of_iterations = 100;
// Always call reserve when you know the size.
vec.reserve(number_of_iterations);
for (auto i = 0; i < number_of_iterations; ++i) {
  vec.emplace_back(42.42F);
}
```


---

# Example vector

```cpp
#include <string>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {1, 2, 3};
  std::vector<std::string> names = {"Igor", "Olga"};
  names.push_back("Cyrill");
  std::cout << "First name: " << names.front() << std::endl;
  std::cout << "Last number: " << numbers.back() << std::endl;
  return 0;
}
```

---

# All variables live in scopes
- There is a single global scope (outside of all functions)
- Local scopes start with `{` and ends with `}`
- All variables **live in the scope** where they have been declared
- All variables die in the **end of their scope**
- Variables can "shadow" other variables in outer scopes
- ‚ÄºÔ∏è This is the core principle of C++ memory management!
```cpp
// üò± Don't put variables here, just an illustration
int global_variable{42};  

int main() {  // Start of main scope
  float some_float = 13.13F;  // Create variable
  {  // New inner scope
    auto some_float = 42.42F;  // "Shadows" some_float
    auto another_float = some_float;  // Copy variable
  }  // another_float and shadow of some_float die
  return 0;
}  // Variable some_float dies
// Variable global_variable dies at the end of the program
```

---

# Any variable can be const
- Use `const` to declare a **constant**
- The compiler will guard it from any changes
- Keyword `const` can be used with **any** type
- üé® Name constants in the **global scope** in `CamelCase` starting with a small letter `k`:
```cpp
const float kImportantFloat = 42.42f;
const std::string kHello = "hello";
```
- üé® Name constants in any **local scope** in `snake_case`
```cpp
const auto local_scope_constant{42UL};
```
- Keyword `const` is part of the variable's type:
  variable `kSomeInt` above has type `const int`
- **Tip:** declare everything `const` unless it **must** be changed

---
# constexpr ???

---
# Variables can be initialized from other variables

---

# References to variables
- We can create a **reference** to any variable
- Use `&` to state that a variable is a reference
  - `float & ref = original_variable;`
  - `std::string & hello_ref = hello;`
- Reference is part of the type:
  variable `ref` has type `float &`
- Changing a reference changes the variable and vice versa
    ```c++
    int some_variable = 42;
    int& some_variable_ref = some_variable;
    some_variable_ref = 23;
    // some_variable is now == 23
    ```
- Yields performance gain as references **avoid copying data**

---

# Const with references
- References are fast but reduce control
- To avoid unwanted changes use `const`
  - `const float & ref = original_variable;`
  - `const std::string & hello_ref = hello;`

```cpp
#include <iostream>

int main() {
  int num = 42;  // Name has to fit on slides ¬Ø\_(„ÉÑ)_/¬Ø
  int& ref = num;
  const int& const_ref = num;
  ref = 0;
  std::cout << ref << " " << num << " " << const_ref << std::endl;
  num = 42;
  std::cout << ref << " " << num << " " << const_ref << std::endl;
  return 0;
}
```