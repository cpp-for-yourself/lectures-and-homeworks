---
marp: true
theme: custom-theme
footer: ![width:80px](images/C++ForYourselfIcon.png)
---

# Basics of C++
#### Variables and some useful types
- Variables
- Basic types
- More interesting types
  - `std::string`
  - `std::array`
  - `std::vector`
  - Streams
- `const`, `constexpr` and references
---
# Prerequisites:
- [Hello world dissection lecture](1.1_hello_world_dissection.md)

---
# Special symbols used in slides
- ğŸ¨ - Style recommendation
- ğŸ“ - Software design recommendation
- ğŸ˜± - **Not** a good code snippet or line of code! Avoid in real life!
- âŒ - Don't do whatever follows (or precedes) this
- âœ… - Do this instead
- ğŸš¨ - Alert! Important information!

Style (ğŸ¨) and software design (ğŸ“) recommendations mostly come from [Google Style Sheet](https://google.github.io/styleguide/cppguide.html) and the [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)

---

# Declaring variables
Variable declaration follows one of the following patterns:
```cpp
Type variable_name;  // ğŸ˜± Uninitialized! Contains random value!
Type variable_name = value;
Type variable_name{value};  // Follows "uniform initialization"
Type variable_name{};  // "Value initialization" if possible
Type variable_name(value);  // âŒ Mostly not used nowadays
```
- Every variable **has a type** - one of the defining features of C++
- Variables cannot change their type
- Variables cannot be assigned an incompatible type

---

# Naming variables

- Name **must** start with a letter
- C++ is case sensitive:
  `some_var` $\ne$ `some_Var` $\ne$ `someVar`
- ğŸ¨ Give variables **meaningful names**
- ğŸ¨ Don't be afraid to **use longer names**
- ğŸ¨ Name variables in `snake_case`
  (all lowercase, underscores separate words)
- ğŸ¨:x: **Don't include type** in the name
- ğŸ¨:x: **Don't use negation** in the name


<!-- _footer: Google naming rules: https://google.github.io/styleguide/cppguide.html#General_Naming_Rules ![width:80px](images/C++ForYourselfIcon.png) -->

---

# Always initialize all variables! ğŸš¨
## (if you can)

There are rare cases where this is not possible like [performance](draft_performance.md) considerations, we will cover them later in the course
```cpp
int sad_uninitialized_variable;  // ğŸ˜± Really, don't do this!
```
```cpp
bool initializing_is_good = true;  // âœ… Always initialize!
bool use_uniform_initialization{true};
auto also_works_with_auto{true};
bool set_to_default_value{};  // Will initialize to false
```

---
# Uninitialized variable example ğŸ˜±

Let's consider an example:
```cpp
#include <iostream>
int main() {
    double uninitialized_variable;  // ğŸ˜± Don't do this!
    std::cout << uninitialized_variable << std::endl;
}
```
Here is the typical output:
```
Î» â€º ./test
2.14188e-314
Î» â€º ./test
2.12718e-314
Î» â€º ./test
2.12991e-314
```
- The value of `uninitialized_variable` is "undefined"
- Your results will (probably) be different!
- Relying on this value causes **"Undefined Behavior"** (**UB**)

---

# "Out of the box" types in C++
```cpp
bool this_is_fun = false;      // Boolean: true or false
char caret_return = '\n';      // Single character
int meaning_of_life = 42;      // Integer number
short smaller_int = 42;        // Short number
long bigger_int = 42L;         // Long number (L is a literal)
float fraction = 0.01f;        // Single precision float
double precise_num = 0.01;     // Double precision float
double scientific = 2.42e-10;  // Double precision float
auto some_int = 13;            // Automatic type [int]
auto some_float = 13.0F;       // Automatic type [float]
auto some_double = 13.0;       // Automatic type [double]
```
There are also `unsigned` equivalents for integer types
```cpp
unsigned int meaning_of_life = 42U;   // Unsigned integer number
unsigned long bigger_int = 42UL;      // Unsigned long number
auto number = 42'232'424ul;  // Automatic type [unsigned long]
```

`[Advanced]` If curious read detailed info here:
https://en.cppreference.com/w/cpp/language/types

---

# Operations on arithmetic types
- All **character**, **integer** and **floating point** types are **arithmetic**
- Arithmetic operations: `+`, `-`, `*`, `/`, `%` (modulo division)
- Comparisons `<`, `>`, `<=`, `>=`, `==` return `bool`
- `a += 1` $\Leftrightarrow$ `a = a + 1`, same for `-=`, `*=`, `/=`, etc.
- Avoid `==` for floating point types
  (we'll cover a better way later)
### Be careful with unsigned integers!
```cpp
#include <iostream>
int main() {
    std::cout << 23U - 42U << std::endl;
    return 0;
}
```
Prints `4294967277` due to an "underflow" (stay tuned)


<!-- _footer: Read more on arithmetic types: https://en.cppreference.com/w/c/language/arithmetic_types ![width:80px](images/C++ForYourselfIcon.png) -->


---

# Some additional operations
- Logical operations defined over boolean variables:
  **or**: `||`, **and**: `&&`, **not**: `!`
    ```cpp
    bool is_happy = (!is_hungry && is_warm) || is_rich;
    ```
- Additional operations on integer variables:
- `/` is integer division: i.e. `7 / 3 == 2`
- `%` is modulo division: i.e. `7 % 3 == 1`
- **Increment** operator: `a++` $\Leftrightarrow$ `++a` $\Leftrightarrow$ `a += 1`
- **Decrement** operator: `a--` $\Leftrightarrow$ `--a` $\Leftrightarrow$ `a -= 1`
- âŒ **Do not** use de- increment operators within another expression, i.e., ğŸ˜± `a = (a++) + ++b` ğŸ˜±

---
# I/O streams for input and output
- Function `puts` was only good to print constant characters
- Handle `stdin`, `stdout` and `stderr` with streams: 
  - `std::cin` â€” maps to `stdin`
  - `std::cout` â€” maps to `stdout` 
  - `std::cerr` â€” maps to `stderr`
- `#include <iostream>` to use I/O streams 
- Part of the C++ standard library (**STL**)

```cpp
#include <iostream> 
int main() {
    int some_number{};
    std::cin >> some_number;
    std::cout << "number = " << some_number << std::endl; 
    std::cerr << "boring error message" << std::endl; 
    return 0;
}
```

---

# Strings
- `#include <string>` to use `std::string`
- Concatenate strings with `+`
- Check if `str` is empty with `str.empty()`
- Works out of the box with I/O streams

```cpp
#include <iostream>
#include <string>

int main() {
  std::string hello = "Hello";
  std::cout << "Type your name:" << std::endl;
  std::string name = "";  // Init empty.
  std::cin >> name;       // Read name.
  std::cout << hello + ", " + name + "!" << std::endl;
  return 0;
}
```

---

# Use `std::array` for fixed size collections of items
- `#include <array>` to use `std::array`
- Store a **collection of items** of **same type**
- Create from data:
    ```cpp
    std::array<float, 3> arr = {1.0F, 2.0F, 3.0F};
    ```
- Access items with `arr[i]` or `arr.at(i)`
- indexing starts with `0`
- Number of stored items: `arr.size()`
- Useful access aliases:
  - First item: `arr.front() == arr[0UL]`
  - Last item:`arr.back() == arr[arr.size() - 1UL]`

---

# Use `std::vector` if number of items is unknown at compile time
- `#include <vector>` to use `std::vector`
- Vector is implemented as a **dynamic table**
- Access stored items just like in `std::array`
- Remove all elements: `vec.clear()`
- Add a new item in one of two ways:
  - `vec.emplace_back(value)` **[preferred, c++11]**
  - `vec.push_back(value)` **[historically better known]**
#### Use it! It is fast and flexible!
Consider it to be a default container to store collections of items of any _one_ type

---

# Optimize vector resizing
- Many `push_back`/`emplace_back` operations force `std::vector` to change its size many times
- `reserve(n)` ensures that the vector has enough memory to store `n` items
- The parameter `n` can even be approximate
- This is a **very important optimization**
  
```cpp
// Somewhere within the main function
std::vector<float> vec;
const int number_of_iterations = 100;
// Always call reserve when you know the size.
vec.reserve(number_of_iterations);
for (auto i = 0; i < number_of_iterations; ++i) {
  vec.emplace_back(42.42F);
}
```


---

# Example vector

```cpp
#include <string>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {1, 2, 3};
  std::vector<std::string> names = {"Igor", "Olga"};
  names.push_back("Cyrill");
  std::cout << "First name: " << names.front() << std::endl;
  std::cout << "Last number: " << numbers.back() << std::endl;
  return 0;
}
```

---

# All variables live in scopes
- There is a single **global scope** (outside of all functions)
- Local scopes start with `{` and end with `}`
- All variables **live in the scope** where they have been declared
- All variables die in the **end of their scope**
- Variables can "shadow" other variables from outer scopes
- â€¼ï¸ This is the core principle of C++ memory management!
```cpp
// ğŸ˜± Don't put variables here, just an illustration
int global_variable{42};  

int main() {  // Start of main scope
  float some_float = 13.13F;  // Create variable
  {  // New inner scope
    auto some_float = 42.42F;  // "Shadows" some_float
    auto another_float = some_float;  // Copy variable
  }  // another_float and shadow of some_float die
  return 0;
}  // Variable some_float dies
// Variable global_variable dies at the end of the program
```

---

# Any variable can be const
- Use `const` to declare a **constant**
- The compiler will guard it from any changes
- Keyword `const` can be used with **any** type
- ğŸ¨ Name constants in the **global scope** in `CamelCase` starting with a small letter `k`:
```cpp
const float kImportantFloat = 42.42f;
const int kHello{42};
```
- ğŸ¨ Name constants in any **local scope** in `snake_case`
```cpp
const auto local_scope_constant{42UL};
```
- Keyword `const` is part of the variable's type:
  variable `kHello` above has type `const int`
- **Tip:** declare everything `const` unless it **must** be changed

---
# constexpr
Very similar to `const`, but with a crucial differences ğŸš¨
<div class="grid-container">
<div>

### `const`
- Can be used for constants created at **run time**
- Can be initialized with **any** provided value
- _Sometimes_ will be available at compile time
```cpp
int a = 42;
const int b = a;   // âœ…
const int c = 23;  // âœ…
const int d = c;   // âœ…
```

</div>

<div>

### `constexpr`
- Can only be used for constants created at 
  **compile time**
- Can only be initialized from a `constexpr` value
```cpp
int a = 42;
const int a_const = a;
constexpr int b = a;       // âŒ
constexpr int c = a_const; // âŒ
constexpr int d = 23;      // âœ…
constexpr int e = d;       // âœ…
```

</div>
</div>

---
# Variables can be initialized from other variables

- Until now we initialized variables with literal constants
- We can also initialize them with other variables
- This performs a **copy** of the variable under the hood
- There are other mechanisms for this too [(stay tuned)](draft_move_semantics.md)

```cpp
int answer{42};
auto another_answer{answer};
int yet_another_copy = answer;
```

---

# References to variables
- We can create a **reference** to any variable
- Use `&` to state that a variable is a reference
  - `float & ref = original_variable;`
  - `std::string & hello_ref = hello;`
- Reference is part of the type:
  variable `ref` has type `float &`
- Changing a reference changes the variable and vice versa
    ```c++
    int some_variable = 42;
    int& some_variable_ref = some_variable;
    some_variable_ref = 23;
    // some_variable is now == 23
    ```
- Yields performance gain as references **avoid copying data**

---

# Const with references
- References are fast but reduce control
- To avoid unwanted changes use `const`
  - `const float & ref = original_variable;`
  - `const std::string & hello_ref = hello;`

```cpp
#include <iostream>
using std::cout;  // Now use cout without the std:: prefix
using std::endl;  // Now use endl without the std:: prefix

int main() {
  int num = 42;  // Name has to fit on slides Â¯\_(ãƒ„)_/Â¯
  int& ref = num;
  const int& const_ref = num;
  ref = 0;
  cout << ref << " " << num << " " << const_ref << endl;
  num = 42;
  cout << ref << " " << num << " " << const_ref << endl;
  return 0;
}
```